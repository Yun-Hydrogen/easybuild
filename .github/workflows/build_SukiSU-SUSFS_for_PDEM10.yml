name: 构建内核并集成 SukiSU 修复 techpack Makefile V2

on:
  workflow_dispatch:

env:
  KERNEL_REPO: https://github.com/Yun-Hydrogen/Oppo_Findx2_Sukisu_Kernel.git
  KERNEL_BRANCH: oss-t
  CLANG_REPO: https://github.com/blacklytning/clang-13.0.1.git
  CLANG_BRANCH: 11
  GCC64_REPO: https://github.com/JackA1ltman/Google-GCC-Android-4.9.git
  GCC64_BRANCH: aarch64
  GCC32_REPO: https://github.com/JackA1ltman/Google-GCC-Android-4.9.git
  GCC32_BRANCH: arm32
  AK3_SOURCE: https://github.com/osm0sis/AnyKernel3.git
  AK3_BRANCH: master
  SUKISU_MODE: susfs-main
  DEFCONFIG: stock_defconfig
  ARCH: arm64
  DEVICE: PDEM10
  CROSS_COMPILE_AARCH64: aarch64-linux-android-
  CROSS_COMPILE_ARM: arm-linux-androideabi-
  # 统一输出目录，避免混用导致检测失败
  KBUILD_OUTPUT: ${{ github.workspace }}/kernel/out

jobs:
  build:
    runs-on: ubuntu-22.04
    steps:
      - name: 检出仓库
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 安装依赖并配置 python2
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential bc bison flex libssl-dev libncurses-dev ccache python2 git wget zip unzip binutils curl lld
          sudo ln -sf /usr/bin/python2 /usr/bin/python
          python --version

      - name: 恢复/克隆工具链
        run: |
          [ -d clang ] || git clone --depth=1 --branch $CLANG_BRANCH $CLANG_REPO clang
          [ -d gcc64 ] || git clone --depth=1 --branch $GCC64_BRANCH $GCC64_REPO gcc64
          [ -d gcc32 ] || git clone --depth=1 --branch $GCC32_BRANCH $GCC32_REPO gcc32
          ls -la clang gcc64 gcc32 || true

      - name: 克隆内核源码
        run: |
          rm -rf kernel
          git clone --depth=1 --branch $KERNEL_BRANCH $KERNEL_REPO kernel
          ls -la kernel

      - name: 设置环境变量（PATH 与 KBUILD_OUTPUT）
        run: |
          echo "PATH=$PWD/clang/bin:$PWD/gcc64/bin:$PWD/gcc32/bin:$PATH" >> $GITHUB_ENV
          echo "CROSS_COMPILE_AARCH64=${{ env.CROSS_COMPILE_AARCH64 }}" >> $GITHUB_ENV
          echo "CROSS_COMPILE_ARM=${{ env.CROSS_COMPILE_ARM }}" >> $GITHUB_ENV
          echo "HOSTPYTHON=/usr/bin/python2" >> $GITHUB_ENV
          echo "PYTHON=/usr/bin/python2" >> $GITHUB_ENV
          # 确保 KBUILD_OUTPUT 一致（避免 make 检测到 .. 作为源）
          echo "KBUILD_OUTPUT=${{ env.KBUILD_OUTPUT }}" >> $GITHUB_ENV

      - name: 在源码顶层做彻底清理以避免 'Using .. as source' 错误
        working-directory: kernel
        run: |
          set -e
          LOG="$GITHUB_WORKSPACE/kernel/setup.log"
          echo "=== CLEAN START $(date) ===" >> "$LOG"
          # 先尝试 make mrproper（不带 O=out）清理源码顶层残留
          if command -v make >/dev/null 2>&1; then
            make mrproper || true
          fi
          # 删除 include/config（常见触发点）
          rm -rf include/config || true
          # 保守的 git 清理
          git reset --hard || true
          git clean -fdx || true
          # 再清理输出目录（如果存在）
          rm -rf out || true
          echo "=== CLEAN END $(date) ===" >> "$LOG"

      - name: 捕获并记录准备与修补日志
        working-directory: kernel
        run: |
          set -e
          LOG="$GITHUB_WORKSPACE/kernel/setup.log"
          echo "=== START setup $(date) ===" >> "$LOG"

          # 备份 .config（如存在）
          if [ -f .config ]; then
            cp .config /tmp/config.backup || true
            echo ".config backed up" >> "$LOG"
          fi

          # 使用 O=out 的 mrproper 以清理输出目录残留（双保险）
          make O=out mrproper >> "$LOG" 2>&1 || true

          # 修补 techpack/display/msm/Makefile：保守移除触发警告的行并在末尾追加 ifndef 块（不会破坏现有结构）
          MF="techpack/display/msm/Makefile"
          if [ -f "$MF" ]; then
            echo "Patching $MF" >> "$LOG"
            cp "$MF" "${MF}.bak" || true

            sed -i '/Defined OPLUS_FEATURE_PXLW_IRIS5/d' "$MF" || true
            sed -i '/PXLW_IRIS_DUAL/d' "$MF" || true
            sed -i '/\$(warning.*OPLUS_FEATURE_PXLW_IRIS5)/d' "$MF" || true
            sed -i '/\$(warning.*PXLW_IRIS_DUAL)/d' "$MF" || true

            if ! grep -q "ifndef OPLUS_FEATURE_PXLW_IRIS5" "$MF"; then
              printf '\nifndef OPLUS_FEATURE_PXLW_IRIS5\nOPLUS_FEATURE_PXLW_IRIS5 := y\nendif\n' >> "$MF"
            fi

            if ! grep -q "ifndef PXLW_IRIS_DUAL" "$MF"; then
              printf '\nifndef PXLW_IRIS_DUAL\nPXLW_IRIS_DUAL := y\nendif\n' >> "$MF"
            fi

            echo "Patched $MF tail (last 60 lines):" >> "$LOG"
            tail -n 60 "$MF" >> "$LOG" 2>&1 || true
          else
            echo "$MF not found, skipping patch" >> "$LOG"
          fi

          echo "=== END setup $(date) ===" >> "$LOG"

      - name: 运行 SukiSU 集成脚本（Manual hook / SUSFS）
        working-directory: kernel
        run: |
          set -e
          LOG="$GITHUB_WORKSPACE/kernel/setup.log"
          echo "=== START SukiSU $(date) ===" >> "$LOG"
          echo "Downloading SukiSU setup.sh" >> "$LOG"
          curl -fsSL https://raw.githubusercontent.com/SukiSU-Ultra/SukiSU-Ultra/main/kernel/setup.sh -o /tmp/sukisu-setup.sh
          chmod +x /tmp/sukisu-setup.sh
          # 传入模式并记录输出
          /tmp/sukisu-setup.sh ${SUKISU_MODE} >> "$LOG" 2>&1 || ( echo "SukiSU setup.sh failed, see setup.log" && exit 1 )
          echo "SukiSU setup completed" >> "$LOG"
          echo "=== END SukiSU $(date) ===" >> "$LOG"

      - name: 启用 Manual hook 的内核配置项（非交互）
        working-directory: kernel
        run: |
          set -e
          LOG="$GITHUB_WORKSPACE/kernel/setup.log"
          if [ ! -x scripts/config ]; then
            chmod +x scripts/config || true
          fi
          # 使用 scripts/config 修改 .config（如果不存在会在后面生成）
          scripts/config --file .config --enable CONFIG_KSU_MANUAL_HOOK || true
          # 使用 non-interactive olddefconfig（确保 .config 与 out/.config 一致）
          export KBUILD_OUTPUT=${{ env.KBUILD_OUTPUT }}
          yes "" | make O=out ARCH=$ARCH olddefconfig HOSTPYTHON=/usr/bin/python2 >> "$LOG" 2>&1 || true
          grep -E "KSU_MANUAL_HOOK|KPROBES" -n .config >> "$LOG" 2>&1 || true

      - name: 准备 defconfig（非交互）
        working-directory: kernel
        run: |
          set -e
          LOG="$GITHUB_WORKSPACE/kernel/setup.log"
          export ARCH=${{ env.ARCH }}
          export KBUILD_OUTPUT=${{ env.KBUILD_OUTPUT }}
          yes "" | make O=out ARCH=$ARCH ${DEFCONFIG} HOSTPYTHON=/usr/bin/python2 >> "$LOG" 2>&1 || true

      - name: 验证交叉链接器可用
        working-directory: kernel
        run: |
          set -e
          LOG="$GITHUB_WORKSPACE/kernel/setup.log"
          export PATH=$GITHUB_WORKSPACE/clang/bin:$GITHUB_WORKSPACE/gcc64/bin:$GITHUB_WORKSPACE/gcc32/bin:$PATH
          export KBUILD_OUTPUT=${{ env.KBUILD_OUTPUT }}
          if command -v ${CROSS_COMPILE_AARCH64}ld >/dev/null 2>&1; then
            ${CROSS_COMPILE_AARCH64}ld --version >> "$LOG" 2>&1 || true
          else
            echo "ERROR: cross linker ${CROSS_COMPILE_AARCH64}ld not found" >> "$LOG"
            ls -la gcc64/bin >> "$LOG" 2>&1 || true
            exit 1
          fi
          ld --version >> "$LOG" 2>&1 || true

      - name: 编译并记录完整构建日志
        working-directory: kernel
        run: |
          set -e
          BUILD_LOG="$GITHUB_WORKSPACE/kernel/build.log"
          echo "=== START build $(date) ===" > "$BUILD_LOG"
          export PATH=$GITHUB_WORKSPACE/clang/bin:$GITHUB_WORKSPACE/gcc64/bin:$GITHUB_WORKSPACE/gcc32/bin:$PATH
          export KBUILD_OUTPUT=${{ env.KBUILD_OUTPUT }}
          # 使用一致的 O=out 与 CC=clang
          make -j$(nproc) O=out ARCH=$ARCH CC=clang CROSS_COMPILE=${CROSS_COMPILE_AARCH64} HOSTCC=gcc LD=${CROSS_COMPILE_AARCH64}ld HOSTLD=ld.bfd HOSTPYTHON=/usr/bin/python2 >> "$BUILD_LOG" 2>&1 || ( echo "MAKE FAILED, see $BUILD_LOG" && cat "$BUILD_LOG" && exit 1 )
          echo "=== END build $(date) ===" >> "$BUILD_LOG"

      - name: 立即备份并准备原始产物（未打包）
        if: success()
        working-directory: kernel
        run: |
          set -e
          RAW_DIR="$GITHUB_WORKSPACE/raw_artifacts"
          mkdir -p "$RAW_DIR"
          cp -v out/arch/arm64/boot/Image* "$RAW_DIR/" 2>/dev/null || true
          cp -v out/System.map "$RAW_DIR/" 2>/dev/null || true
          if [ -d out/lib/modules ]; then
            mkdir -p "$RAW_DIR/modules"
            cp -r out/lib/modules/* "$RAW_DIR/modules/" || true
          fi
          echo "raw_artifacts content:" >> "$GITHUB_WORKSPACE/kernel/setup.log"
          ls -la "$RAW_DIR" >> "$GITHUB_WORKSPACE/kernel/setup.log" 2>&1 || true

      - name: 上传原始产物
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: raw-${{ env.DEVICE }}
          path: raw_artifacts

      - name: 打包 AnyKernel3（修改 anykernel.sh：设备名 + auto block/slot）
        if: success()
        working-directory: kernel
        run: |
          set -e
          git clone --depth=1 --branch $AK3_BRANCH $AK3_SOURCE AnyKernel3
          mkdir -p AnyKernel3/kernel
          cp -r $GITHUB_WORKSPACE/raw_artifacts/* AnyKernel3/kernel/ || true
          AKSH=AnyKernel3/anykernel.sh
          if [ -f "$AKSH" ]; then
            sed -i 's/^kernel.string=.*/kernel.string="PDEM10 Kernel by Hydrogen"/' "$AKSH" || echo 'kernel.string="PDEM10 Kernel by Hydrogen"' >> "$AKSH"
            sed -i 's/^device.name1=.*/device.name1=PDEM10/' "$AKSH" || echo 'device.name1=PDEM10' >> "$AKSH"
            sed -i 's/^BLOCK=.*/BLOCK=auto/' "$AKSH" || echo 'BLOCK=auto' >> "$AKSH"
            sed -i 's/^IS_SLOT_DEVICE=.*/IS_SLOT_DEVICE=auto/' "$AKSH" || echo 'IS_SLOT_DEVICE=auto' >> "$AKSH"
          else
            echo "Warning: AnyKernel3/anykernel.sh not found" >> "$GITHUB_WORKSPACE/kernel/setup.log"
          fi
          cd AnyKernel3
          OUT_ZIP="$GITHUB_WORKSPACE/${DEVICE}-kernel.zip"
          zip -r9 "$OUT_ZIP" . -x ".git/*" "README.md" "*placeholder"
          echo "Generated zip: $OUT_ZIP" >> "$GITHUB_WORKSPACE/kernel/setup.log"
          ls -lah "$OUT_ZIP" >> "$GITHUB_WORKSPACE/kernel/setup.log" 2>&1 || true

      - name: 上传打包产物
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.DEVICE }}-kernel
          path: ${{ env.DEVICE }}-kernel.zip

      - name: 上传日志 artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs
          path: |
            kernel/setup.log
            kernel/build.log
